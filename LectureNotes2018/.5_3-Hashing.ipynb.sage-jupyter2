{"backend_state":"ready","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":16.279069767430844,"memory":36102144},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.6.9"}},"trust":false,"type":"settings"}
{"cell_type":"code","collapsed":true,"exec_count":0,"id":"7c8f31","input":"def linearProbing(ind,hashTable,data):\n    count=ind\n    found=False\n    \n    while (count!=ind-1) and not(found):\n        \n        if hashTable[count]=='none':\n            found=True\n            hashTable[count]=data\n            \n        else:\n            count=count+1\n            if count==len(hashTable)-1:\n                count=0\n    return(hashTable)\n\ndef putData3(a,hashTable,functionName):\n    \n    for i in range(len(a)):\n       \n        if functionName=='reminder':\n            ind=remainderFunction(a[i],len(hashTable))   \n            \n        elif functionName=='midSq':\n            ind=midSqFunction(a[i],len(hashTable))  \n        \n       \n        if hashTable[ind]=='none':\n            hashTable[ind]=a[i]\n        else:\n            hashTable=linearProbing(ind,hashTable,a[i])    \n        \n\n    return(hashTable)\n\n    ","pos":25,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":0,"id":"5e230b","input":"a=[54, 26, 93, 17, 77, 31]\nhashTable=createHashTable(11)\nprint(hashTable)\nhashTable=putData3(a,hashTable,'reminder')\nprint(hashTable)","pos":26,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":0,"id":"ae84b5","input":"print(strVal('dia'))\nprint(strVal('adi'))","pos":19,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":0,"id":"b60f26","input":"def strVal(strData):\n    temp=0\n    for i in range (len(strData)):\n        temp=temp+ord(strData[i])\n    return(temp)","pos":16,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":0,"id":"c29421","input":"strVal('indonesia')","pos":17,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":0,"id":"cb51fe","input":"a=[54, 26, 93, 17, 77, 31,44,55,20]\nhashTable=createHashTable(11)\nprint(hashTable)\nhashTable=putData3(a,hashTable,'reminder')\nprint(hashTable)","pos":27,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":2,"id":"9ff5f4","input":"def remainderFunction (data,num):\n    return (data%num)\n\ndef createHashTable(num):\n    temp=[]\n    for i in range(num):\n        temp.append('none')\n    return(temp)\ndef putData(data,table):\n    for i in range(len(data)):\n        ind=remainderFunction(data[i],len(table))  \n        table[ind]=data[i]\n    return(table)\n\ndef searchHash(data,table):\n    hashVal=remainderFunction(data,len(table))\n    if data==table[hashVal]:\n        return True\n    else:\n        return False\n        ","pos":7,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":3,"id":"f2e8e4","input":"a=[54, 26, 93, 17, 77, 31]\nhashTable=createHashTable(11)\nprint(hashTable)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"['none', 'none', 'none', 'none', 'none', 'none', 'none', 'none', 'none', 'none', 'none']\n"}},"pos":9,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":4,"id":"fd5a1b","input":"hashTable=putData(a,hashTable)\nprint(hashTable)","output":{"0":{"name":"stdout","output_type":"stream","text":"[77, 'none', 'none', 'none', 26, 93, 17, 'none', 'none', 31, 54]\n"}},"pos":10,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":5,"id":"839445","input":"searchHash(93,hashTable)","output":{"0":{"data":{"text/plain":"True"},"exec_count":5,"output_type":"execute_result"}},"pos":11,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"088bfe","input":"Hash function ini memegang peranan penting dalam algoritma hashing, dengan hash function ini, data didalam list disusun berdasarkan nilai hash, dan pencarian data dilakukan berdasarkan **nilai hash** dari hash function ini.  Hash function memiliki parameter nilai data (baik data yang akan disusun didalam list ataukah data yang akan dicari), dan mengembalikan nilai integer (nilai hash) yang merupakan representasi dari **nomor slot**.\n\nContoh hash function yang paling sederhana adalah **remainder function**.  Pada fungsi ini, parameter adalah nilai data, dan nilai balik berupa modulus dari data tersebut dengan sebuah angka (misal ukuran dari tabel). Fungsi ini hanya menghitung modulus dari suatu data, contoh, terdapat data dengan nilai 54, maka nilai hash = 54 % 11, yaitu 4.\n\nBerikut contoh data dan nilai hash, dengan fungsi modulus 11 (ukuran tabel).  \n\n|    Data   |  Nilai *Hash*  |\n|-----------|----------------|\n|    54     |       10       |\n|    26     |        4       |\n|    93     |        5       |\n|    17     |        6       |\n|    77     |        0       |\n|    31     |        9       | \n\nSehingga dengan data dan nilai hash tersebut, maka representasi data di dalam hash table, dapat dilihat pada Gambar 2 berikut. <br>\n![title](images/hashTable.png) <br>\n**Gambar 2. Hash Table dengan data pada beberapa slot**<br>\n\nSetelah semua data berada di dalam hash table, maka dapat dihitung **Load factor** dari hash table, yang merupakan presentasi pemakaian hash tabel, dengan menggunakan persamaan $\\lambda=\\frac{jumlahData}{ukuranTabel}$\n\n\nPencarian data dilakukan hanya dengan cara menghitung function hash berdasarkan data tersebut, dan nilai balik data tersebut merupakan index atau slot dari data di dalam list, kemudian dilakukan pengecekan keberadaan data tersebut hanya dengan satu kali perbandingan saja.","pos":5,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"0b1506","input":"## Penanganan *Collusion*\n\n*Perfect Hash Function* meminimalisir terjadinya colluision, akan tetapi terkadang, collusion ini tidak dapat dihindari, sehingga diperluka penanganan atau yang dikenal dengan **collusion resolution**.  \n\nPenangan collusion ini dapat dilakukan dengan cara mencari kembali di dalam hash table slot yang kosong untuk data yang menyebabkan terjadinya collusion. Penanganan ini dikenal dengan konsep **open addressing**, yaitu pencarian slot kosong yang siap ditempati oleh data baru.\n\nContoh penanganan collusion sederhana berdasarkan konsep open adressing ini adalah **Linear Probing**, yaitu mencari slot kosong dengan cara mengunjungi slot-slot ini satu persatu, dimulai dari slot tempat terjadinya collusion.\n\n","pos":23,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"0f13cc","input":"## Fungsi Hash untuk String\n\nJika sebelumnya data yang digunakan adalah data dengan tipe integer, maka hash function juga dapat digunakan untuk data bertipe string.  Nilai dari sebuah string dapat diambil dari jumlah nilai ascii karakter-karakter penyusun data string tersebut.  Untuk mendapat nilai ascii dari suatu karakter, dapat menggunakan perintah **ord**.  Berikut fungsi untuk mendapat nilai ascii dari suatu string.","pos":14,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"192adb","input":"[**Kembali ke Menu Awal**](#Pengurutan/Sorting)","pos":22,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"20a43f","input":"[**Kembali ke Menu Awal**](#Pencarian/Searching)","pos":3,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"2390a3","input":"## Code\n\nBerikut adalah fungsi-fungsi yang diperlukan untuk algoritma hashing ini, antara lain :\n- hash function (gunakan remainder function, yaitu data dimodulus dengan 11), nilai balik merupakan nilai hash\n- createHashTable, untuk membuat hash table, dengan inisialisasi semua slot berisi 'none'\n- putData, yaitu menyusun data ke dalam hash table, berdasarkan nilai hash yang dihasilkan\n- searchHash, argumen merupakan data yang dicari, dan nilai balik berupa True or False, yaitu apakah data ditemukan di dalam hash table","pos":6,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"2577db","input":"[**Kembali ke Menu Awal**](#Pengurutan/Sorting)","pos":31,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"381688","input":"Untuk mengatasi hal ini, dapat digunakan bobot yang menunjukkan posisi masing-masing karakter dari suatu string.  Seperti yang terdapat pada Gambar 3 berikut <br>\n![title](images/weightedString.png)<br>\n**Gambar 3. Bobot tiap karakter**<br>","pos":20,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"471da3","input":"### Latihan - 5\nBuat function untuk penanganan collusion chaining dan proses pencariannya","pos":30,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"472411","input":"## Hashing\n\n\nPencarian akan lebih **cepat** lagi jika semua data pada list terletak **tepat** berada ditempatnya masing-masing, sehingga pencarian dilakukan hanya dengan **satu kali** proses perbandingan saja.  Algoritma ini dikenal dengan nama **Hashing**.\nDi dalam algoritma hashing ini terdapat beberapa istilah dasar sebagai berikut:\n- **Hash Table**, yaitu sebuah tempat penyimpanan data, yang dibuat sedemikian rupa, sehingga dapat memudahkan pencarian.  Tipe data list di python dapat digunakan untuk merepresentasikan hash table\n- **slot**, yaitu posisi (indeks) yang terdapat pada hash table sebagai tempat penyimpanan setiap data.  Karena slot berfungsi seperti halnya indeks, maka nilai slot adalah nilai integer mulai dari nol sampai dengan ukurang dari hash table, misalkan slot 0, slot 1, slot 2, .... , slot $n$.  Contoh hash table dan slot yang masih kosong dapat dilihat pada Gambar 1. Pada Gambar tersebut terdapat sebuah hash table dengan 11 slot kosong : <br>\n![title](images/emptyHashTable.png) <br>\n**Gambar 1. Hash Table kosong** <br>\n\n\n- **Hash function**, yaitu suatu fungsi yang memetakan antara data dengan slot di dalam hash table","pos":2,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"4ee89d","input":"### Code\n\nBerikut code untuk pembuatan fungsi Linear Probing.<br>\n\nMisalkan terdapat data a=[54, 26, 93, 17, 77, 31], dan hash function yang digunakan adalah remainder function, maka tambahkan fungsi linear probing, agar dapat memasukkan data baru yaitu 44, 55, dan 20, sehingga a= [54, 26, 93, 17, 77, 31, 44, 55, 20]","pos":24,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"572397","input":"Berikut adalah contoh data dan pencarian dengan menggunakan konsep hashing","pos":8,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"69ff83","input":"### Latihan - 4\n\nModifikasi fungsi strVal diatas, agar bobot masing-masing karakter diperhitungkan.","pos":21,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"7df408","input":"### Latihan - 3\n\nBuatlah hash function *mid-square function*\n","pos":13,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"8c3cee","input":"## Code\n\nBerikut code untuk mendapatkan nilai ascii dari suatu karakter","pos":15,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"afb671","input":"Permasalahan timbul ketika terdapat data dengan nilai hash yang sama, sehingga akan mengacu pada nomor slot yang sama.  Contoh pada data sebelumnya, terdapat data 44, dengan menggunakan **Remainder hash function** maka nilai hash sama dengan 0, sedangkan slot 0, sudah ditempati oleh data 77.  Permasalahan ini dikenal dengan **collusion**.  \n\nUntuk meminimalkan terjadinya *collusion* ini, diperlukan adanya **perfect hash function**, yaitu suatu hash function yang memetakan data tepat ke slot yang unik.  Sehingga sebuah slot hanya ditempati oleh sebuah data saja.   Tujuan dari **perfect hash function** ini meminimalkan terjadinya **collusion**.\nContoh perfect hash function adalah **mid-square method**, yaitu kuadratkan nilai data, kemudian ambil bagian tertentu dari data tersebut.  Misalkan terdapat data 35, maka $35^2=1225$, dan character yang terletak di bagian tengah dari 1225 adalah '22', kemudian lakukan perhitungan modulus dengan ukuran table, misalkan 22%11, yaitu 0\n","pos":12,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"cfa502","input":"Jika pada **Linear Probing**, penempatan data dilakukan dengan cara mencari satu persatu slot kosong dari posisi terjadinya collusion, maka **quadratic probing**, yaitu data collusion diletakkan dengan cara menambahkan posisi collusion dengan nilai sebagai berikut : 1, 3, 5, 7, 9, ...\nContoh quadratic probing dapat dilihat pada Gambar berikut :\n![title](images/quadraticProbing.png)","pos":28,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"d50d70","input":"# <font color=blue>Pencarian/*Searching*</font>\n\n\nHashing\n***","pos":0,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"e62c6d","input":"Hanya saja, fungsi tersebut akan menghasilkan nilai yang sama terhadap anagram. Misalkan nilai dari kata 'dia' sama dengan 'adi'","pos":18,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"eb450f","input":"## Fungsi Hash","pos":4,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"f032a8","input":"Metode lain untuk penanganan collusion ini adalah **Chaining**, dengan chaining ini, satu slot dapat ditempati oleh beberapa data sekaligus. Untuk proses pencarian dilakukan pada slot tersebut.  Contoh chaining ini dapat dilihat pada Gambar berikut ![title](images/chaning.png)","pos":29,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"f2744f","input":"*Sequential Search* mencari data dengan cara membandingkan data yang dicari dengan setiap data yang terdapat pada list satu persatu dari indeks awal sampai dengan indeks terakhir.  <br>\nSedangkan pada *binary search*, list data dibagi menjadi dua buah grup, dan pencarian akan dilakukan dengan cara membandingkan data yang dicari dengan data yang terdapat pada indeks tengah, jika data yang dicari lebih besar terhadap data yang terdapat pada indeks tengah, maka pencarian berikutnya hanya dilakukan pada grup terakhir saja.  Hal ini dilakukan terus menerus (pembagian list menjadi dua buah grup, pembandingan data yang dicari dengan nilai tengah), sampai data diketemukan, atau data tidak diketemukan.  Oleh karena itu waktu komputasi yang dibutuhkan untuk binary search lebih sedikit dibandingkan dengan sequential search, karena pencarian tidak dilakukan pada setiap data, tapi hanya grup yang memenuhi syarat saja.\n\nAlgoritma searching yang ketiga adalah **Hashing**.  Penjelasan algoritma hashing ini akan dibagi menjadi tiga bagian, yaitu :\n1. [Hashing](#Hashing)\n2. [Fungsi Hash](#Fungsi-Hash)\n3. [Penanganan Collusion](#Penanganan-Collusion)","pos":1,"state":"done","type":"cell"}
{"id":0,"time":1591969715318,"type":"user"}
{"last_load":1591974361592,"type":"file"}